# ruby環境について
macではデフォルトで入っているが、基本古い。<br>
rbenvでバージョン指定してのインストールが可能

https://github.com/rbenv/rbenv
```
//まずはbrewでrbenvをインスト

brew install rbenv ruby-build

//rubyを開始
rbenv init

//案内に従い、環境変数パスを通す
echo 'eval "$(rbenv init - zsh)"' >> ~/.zshrc

//ようやくバージョン指定してインストール
rbenv install 3.2.2

//利用するバージョンを変更
rbenv global 2.7.4

```

# 構文やルールなどメモ
・ガーベージレコレクションは気にしなくてok
<br>

・.class関数は、そのクラスを返す<br>

・phpと同じような三項演算子が使える<br>

・puts で出力。ただし、irbではputsを置かなくても出力を返してくれる。<br>

・rubyでは ++ などのオートインクリメントは使えない。 hensuu+-1 などで1増やそう。<br>

・偽の判定にはfalseと「nil」がある<br>

・丸め誤差に注意。rubyでは数字末尾にrをつけるとRationalクラスになり、ちゃんと計算される。
```
 0.1 * 3.0 == 0.3 //false
 
 0.1r * 3.0r == 0.3//true
```

・rubyでは、ifやdef（メソッド)の中で、returnを使わなくても返してくれる。<br>
のでわざわざ書かなくても良い。途中で抜ける時に書くことが多い<br>
<br>
・メソッドの引数がない場合は（）も不要。なんなら引数があっても、実はつけなくても良い。

# 文字列について
%Q! はダブルクォートで囲んだことになる。!は他の文字でもok。こう使うことで、クウォートでちょっとわかりづらい状態にならない。
```
a = 'a'
puts %Q!やあやあ、#{a}くん。!  #やあやあ、aくん
```

# 数値について
・10進数以外の整数<br>
0bを先頭につけると 2進数として認識する。0だと8進数。0xなら16進数
```
0b11 #3
011 #9
```

# 関数について
php見たく、引数にデフォルト値を指定できる。
```
def メソッド名(引数1、引数2 = 'デフォルト値'
  処理
end
```

真偽値を返すメソッドには、?がつく。empty?など。<br>
!で終わるメソッドは、扱いに注意なもの。upcase!とupcaseとかがある。破壊的なものとか。


# roopについて

rubyではforはあまり使わない。eachがよく使われる。
```
numbers = [1,2,3]
sum = 0
numbers.each do |n|
 sum += n
end
```

deleate_ifという関数でmapみたいな感じで特定の条件の配列の値を削除できる。<br>
他に、select、reject(trueかfalseをフィルタリングする)

#eachメソッドに添え字も使いたい場合はeach_with_index

```
hoge.each_with_index{|_hoge,i| puts "#{i}:#{_hoge}"}
```
他に、mapと一緒に使えるwith_indexとかもある。任意の添え字から利用できる。

# 範囲オブジェクトについて
(1..5) とか、 ('a'..'e')とか。これはRangeクラスのオブジェクト。<br>
..と...の違い（2つか3つか）として、1..5だと、5が含まれる。...だと5は含まれる4.9999までになる。<br>
どういう時に使うかは、チェリー本100,101あたり3勝。配列の添え字とか、caseとかで役にたつ。<br><br>
また、範囲オブジェクトに対してto_aメソッドを使うと、値が連続する配列を作ることができる。
```
(1..5).to_a　=> [1,2,3,4,5] になる
```

# to_sは数字を入れると、その進数に変えてくれる。
```
255.to_s(16) # この場合は16進数。ff.
```

# rjustは指定した引数ぶん、その数字を増やして埋める。
```
'0'.rjust(5) => "    5"
'0'.rjust(5,'0') => "00005"

```

# injectはreduceに似ている。引数が1週目の1値、2週目以降のループでは前の週の返り値が入る
```
  [r,g,b].inject('#') do |hex,n|
    hex + n.to_s(16).rjust(2,'0')
  end
```

# %記法で文字列の配列を簡単に作る
%w!囲みたいもじ ですよ〜〜〜!　とかくと、こうなる

```
["囲みたい","文字ですよ〜〜〜!"]
```

# 配列に追加する場合は << でもできる。

# 配列の中に*を置いた時の挙動
```
a = [1,2,3]
[a] この場合[[1,2,3]]
[*a]こうすると、[1,2,3]になる、
```

# arrayはArray.newでも作成可能。引数1にその数、引数2に初期値を指定できる。
だが、第二引数は同じオブジェクトに紐づくので注意。
```
a = Array.new(3,"default") 
a[0].upcase!
#と、破壊的変更すると、aはこうなる。全部変わってしまう。
["test","test","test"]
#こうしないために、初期値はブロックで渡そう。下記のようにすれば、どれも異なるオブジェクトになる。
Array.new(3){"default"}
```

# each_with_indexで、配列の要素を別々の要素として受け取る方法
```
sample = [
[10,20],
[30,40],
[50,60]

sample.each_with_index do |(a,b),i|
 puts "A:#{a}, B:#{b},i:#{i}"
end

結果
 A:10,B:20,i:0
 A:30,B:40,i:1
 A:50,B:60,i:2

```

# 様々な繰り返し処理について。
times・・・配列を使わずに繰り返しをn回行う。<br>
upto、downto,,,数字を増やすor減らしながら繰り返す。<br>
step・・・2ずつ、または4ずつなど、少しずつ数字を変えながら行う<br>
wile、untile・・・条件が真、または偽の間繰り返される。

rubyでは繰り返しはeachやmapを使うことが多いが、forをつかえば、処理の中で定義したローカル変数も外で使うことができる。<br>

loopはあえて無限ループを使いたい時に利用する。breakで、if ローカル変数が5の場合に処理を終了できる。
```
numbers = [1,2,3]
loop do
 n = numbers.sample #sampleはランダムで返す
 puts n
 break if n == 5;
end
```

・二重ループなどで、外側のループの外まで脱出したい場合は、Kernelモジュールの、throwとcatchを使う。<br>
```
catch 任意のタグ do
 #２重の繰り返し処理など
 throw 任意のタグ
end
```
※rubyにおいては、例外処理はraiseとrescureを使う。

# returnとbreakの違いについて
breakはループから抜けるが、returnはメソッド自体を終了する。(phpとかと同じようなもの。)

# ハッシュとシンボル。
ハッシュは、他言語における連想配列のようなもの。
